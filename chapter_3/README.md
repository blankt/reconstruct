### 代码的坏味道（需要重构的代码）
1. 神秘命名  
准确、易于理解的名字对程序很重要。含糊不清的命名则会加大理解成本。  

2. 重复代码  
一段代码出现在两个以上的地方则需要合并一起，要不然会出现需要修改多处的情况，容易遗漏造成bug。

3. 过长函数  
函数越长越难以理解。  
应当积极点分解函数，并以其用途对其进行命名。  

4. 参数列表过长  
参数列表过长也会使人更加疑惑  
某个参数发起查询可以获取另一个参数 -> 以查询取代参数（324）  
从现有数据结构引用多个字段，直接引用原有对象 -> 保持对象完整（319)  
几个参数总是同时出现 -> 引入参数对象（140）  
参数被用作区分函数的行为的标记 -> 移除标记参数（314）  
多个函数拥有相同的几个参数 -> 函数组合成类（144)  

5. 全局数据  
最常见的是全局变量，这种全局数据会使之无法分辨出哪里会造成这种数据的变化，会出现诡异的bug。  
用函数把全局数据包装起来或者将函数放入一个类、模块中，控制其作用域，让其能在看得见的地方被访问。 -> 封装变量（132）  

6. 可变数据 ？  
同一数据会在不同的地方进行修改。  
保证数据的更新操作通过几个函数进行 -> 封装变量（132）  
变量在不同时候被用于存储不同的东西,拆分为不同用途的变量。 -> 拆分变量（240）  
可变数据能在其他地方计算出来 -> 查询取代派生变量（248）  

7. 发散式变化 ？  
某个模块经常因为不同的原因在不同的方向上发生了变化。  

8. 霰弹式修改  
每遇到某种变化就需要在多种不同的类中做出许多小修改  
把做出修改的代码放进一个模块 -> 搬移函数（198)、搬移字段（207）  
许多函数都在操作相同的数据 -> 函数组合成类（144）  
有些函数的功能是转化或者充实数据结构 -> 函数组合成变换（149）  
有些函数的输出可以组合后提供给一段专门使用这些计算结果的逻辑 -> 拆分阶段（154）  
把本不该分散的逻辑拽回一处 -> 内联函数（115）、内联类（186）  

9. 依恋情结  
一个函数对另一个模块的函数或数据交流特别频繁，远胜自己在所处模块内的交流，两处代码就处于依恋状态。  
迁移代码 -> 提炼函数（106）、搬移函数（198）  

10. 数据泥团  
数据项众多且聚集在一个函数或者模块。
将数据提炼到一起  -> 提炼类（182）、引入参数对象（140）、保持对象完整（319）

11. 基本类型偏执  
有的数据可以用基本类型来表示，但该类数据表达的信息不止是基本类型自身所表达的信息。例如电话号码，是字符串可以表达的，但是本身具有其他固定的属性，例如
格式、归属地等，此时可以将该基本类型包装成对象。  
基本类型包装成对象 -> 对象取代基本类型（174）  
要替换的数据值是控制条件行为的类型码 -> 子类取代类型码（362）+ 多态取代条件表达式（272）  

12. 重复的switch语句
多个地方存在相同的switch语句，增加逻辑时需要修改多处。 -> 多态取代条件表达式（272）  

13. 循环语句
管道操作（如 filter 和 map）可以帮助我们更快地看清被处理的元素以及处理它们的动作，但go语言中还不支持。

14. 冗赘的元素
代码中存在的一些额外的结构使代码看起来更加复杂且无必要存在。 -> 内联函数（115）、内联类（186）、折叠继承体系（380）

15. 夸夸其谈通用性
预先扩展代码的通用性，用各种钩子和特殊情况来处理一些非必要的事，使系统变得更加难以理解和维护(其实大部分都用不着)。 -> 折叠继承体系（380）、内联函数（115）、
内联类（186）、改变函数声明（124）  

16. 临时字段  
类中的一些字段只为处理某种特殊情况，可以为特殊的字段提炼类，并封装相关代码。 -> 提炼类（182）、搬移函数（198）、引入特例（289）  

17. 过长的消息链 ？

18. 中间人 ？  
过多的委托会造成过多的中间代码  

19. 内幕交易  
不同的模块之间存在大量的数据交换，增加了模块之间的耦合，且这种数据交换比较隐秘。  
减少模块之间数据交换。 -> 搬移函数（198）、搬移字段（207）  

20. 过大的类  
利用单个类做过多的事情，内部出现太多字段，重复代码就会频繁出现。    
提炼、拆分类 -> 提炼类（182)、提炼超类（375）、以子类取代类型码（362）  

21. 异曲同工的类  
可以将两个功能类似的类抽象出同一个接口，这样两个类就可以做到互相替换。  

22. 纯数据类  
存在一些包含某些字段、且对这些字段只有读写逻辑的类为纯数据类。这种类一般来说会被其他的类过分细锁的操作，常常意味着逻辑行为被放在了错误的地方。    
将对这个类的一些逻辑行为迁移到这个类内部，对开开放方法。 -> 封装记录（162）、提炼函数（106）、搬移函数（198）  

23. 被拒绝的遗赠  
子类复用了超类的方法（实现），但是拒绝实现父类的其他接口。 -> 委托取代子类（381）、委托取代超类（399）  

24. 注释  
注释的存在是为了解释一段糟糕的代码时，这个时候应该去尝试重构代码，让代码清晰的表达出自己的意图。 -> 提炼函数（106）、改变函数声明（124）

